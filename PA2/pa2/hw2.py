from pathlib import Path
from flask import Flask, render_template, request, Markup,session
from utils import title_match, load_wapo
import time
app = Flask(__name__)
data_dir = Path("pa2_data")
wapo_path = data_dir.joinpath("wapo_pa2.jl")
wapo_docs_titles, wapo_docs = load_wapo(wapo_path)  # load and process WAPO documents

"""
    Runs simple flask app to preform search

    home() -- route for homepage
    results() -- route for results for query 
    next_page() -- route for next page of results; utilizes the results template
    doc_date() -- route for displaying full document information

    Notes:
            I had extra time so to (theoretically) improve the efficiency I utilized the
            session functionality of Flask to store match results as a cookie. This allowed the app
            to pull match data from a secure cookie rather than re-generating them. The way this is implimnented
            accomodates for the possibility that a cookie can not be set or that it is deleted by
            not assuming thier existance. By default sesssion cookies are deleted after the browser is closed.
"""

@app.route("/")
def home():
    """
    home page

    Simply returns the home page
    :return:
    """
    return render_template("home.html")



@app.route("/results", methods=["POST"])
def results():
    """
    result page
    generates a results page by pulling required information out of documents that match a query

    utilizes sessions to store query results in cookies to cut down on repeated operations
    :return:
    returns a rendered template with the following keywords
    matches     -- list of 8 (title,doc_id,150 char snippet) tuples
    page        -- next page
    prev        -- current page
    query       -- text of the query
    max_pages   -- max pages generated by query

    """
    query_text = request.form["query"]  # Get the raw user query from home page
    if not query_text:
        matches =[] #if no query there are no matches
    # if the query matches a cached query return the cached results
    elif query_text.lower() in session:
        matches = session[query_text.lower()]
        print("matches retrieved from session for results")
    else:
        matches = []
        docs = []
        #for each title in the title list
        for title in wapo_docs_titles:
            #if the title matches
            if title_match(query_text,title):
                # pull out variables
                doc_id = wapo_docs_titles[title]
                doc = wapo_docs[doc_id]
                # NOTE: I dont escape the snipit because it causes issues with unfinished html tags
                snipit = doc["content_str"][:150]
                # add match to match results 
                matches.append((title,doc_id,snipit))
        # add match to cache
        session[query_text.lower()] = matches
        # tell session that it is modified
        session.modified=True
        print("matches generated from search for results")
    return render_template("results.html",matches=matches[:min(8,len(matches))],page=1,prev=0,query=query_text,maxpages=len(matches)//8)  # add variables as you wish

# Current iteration of next page--> re-does search with a different page #
@app.route("/results/<int:page_id>", methods=["POST"])
def next_page(page_id):
    """
    "next page" to show more results
    :param page_id: the page requested
    :return:
    returns the next page using data from session
    variables in rendered template are similar to those used in results()
    differences:
    -   the specific pages returned are determined by the page_id
    -   page and prev are modifed to + and - from current page
    """
    query_text = request.form["query"] # grab query from the form
    if not query_text.lower() in session:
        matches = []
        docs = []
        #for each title in the title list
        for title in wapo_docs_titles:
            #if the title matches
            if title_match(query_text,title):
                # pull out variables
                doc_id = wapo_docs_titles[title]
                doc = wapo_docs[doc_id]
                # NOTE: I dont escape the snipit because it causes issues with unfinished html tags
                snipit = doc["content_str"][:150]
                # add match to match results 
                matches.append((title,doc_id,snipit))
        # add match to cache
        session[query_text.lower()] = matches
        # tell session that it is modified
        session.modified=True
        print("cookies either deleted or not allowed")
        print(f"matches generated for page {page_id}")
    else:
        matches = session[query_text.lower()] # grab matches from session cache
        print(f"matches retrieved from session for page {page_id}")
    return render_template("results.html",matches=matches[8*page_id:min(len(matches),8*(page_id+1))],page=page_id+1,prev=page_id-1,query=query_text,maxpages=len(matches)//8)  # add variables as you wish


@app.route("/doc_data/<doc_id>")
def doc_data(doc_id):
    """
    document page
    :param doc_id:
    :return:

    Returns rendered document based on document ID
    """
    return render_template("doc.html",doc=wapo_docs[doc_id],text=Markup(wapo_docs[doc_id]["content_str"]))  # add variables as you wish


if __name__ == "__main__":
    # a secret key is required to utilize sessions
    # key is generated based on a time stamp
    app.secret_key = str(time.time())
    app.run(debug=True, port=5000)